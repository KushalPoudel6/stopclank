CREATE SCHEMA api;

/* TABLES */
CREATE TABLE api.users (
	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	username TEXT NOT NULL,
	password TEXT NOT NULL,
	reverse_string BOOLEAN NOT NULL DEFAULT FALSE
);

INSERT INTO api.users (username, password) VALUES
	('shaco', '123'), ('clone', '456');

/* TODO: remove sessions after time expires */
CREATE TABLE api.sessions (
	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	session_id TEXT NOT NULL,
	username TEXT NOT NULL
);

/* ROLES */
CREATE ROLE session_authorizer NOLOGIN;
GRANT USAGE ON SCHEMA api TO session_authorizer;
GRANT SELECT, INSERT ON api.sessions TO session_authorizer;
GRANT SELECT ON api.users TO session_authorizer;

CREATE ROLE web_anon NOLOGIN;
GRANT USAGE ON SCHEMA API TO web_anon;
GRANT SELECT, UPDATE(reverse_string) ON api.users TO web_anon;
GRANT web_anon TO authenticator;

/* FUNCTIONS */
BEGIN;

/* If username and password match those of an existing user, create a session and return true */
/* On success, session_id is sent as a cookie */
CREATE FUNCTION api.login(login_username TEXT, login_password TEXT)
RETURNS BOOLEAN AS $$
DECLARE
	success BOOLEAN;
	new_session_id UUID;
BEGIN
	success := EXISTS(SELECT * FROM users WHERE username = $1 AND password = $2);
	IF success THEN
		new_session_id := gen_random_uuid();
		INSERT INTO api.sessions (session_id, username) VALUES (new_session_id, $1);
		/* TODO: Configure cookie expiration and use HTTPS + 'Secure' in cookie */
		PERFORM set_config('response.headers', format('[{"Set-Cookie": "session_id=%s; Path=/api; HttpOnly"}]', new_session_id), true);
	END IF;
	RETURN success;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;

ALTER FUNCTION api.login(login_username TEXT, login_password TEXT) OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION api.login(login_username TEXT, login_password TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION api.login(login_username TEXT, login_password TEXT) TO web_anon;

COMMIT;


BEGIN;

CREATE FUNCTION validate_session()
RETURNS VOID AS $$
DECLARE
	current_session_id TEXT := current_setting('request.cookies', true)::JSON->>'session_id';
BEGIN
	IF current_setting('request.method', true) = 'POST' AND current_setting('request.path', true) = '/rpc/login' THEN
		RETURN;
	END IF;
	IF NOT EXISTS(SELECT * FROM sessions WHERE session_id = current_session_id) THEN
		RAISE EXCEPTION 'Could not validate session';
	END IF;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;

ALTER FUNCTION validate_session() OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION validate_session() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION validate_session() TO web_anon;

COMMIT;
