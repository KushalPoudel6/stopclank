CREATE SCHEMA api;
CREATE SCHEMA extensions;

/* TABLES */
CREATE TABLE api.users (
	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	username TEXT NOT NULL,
	password TEXT NOT NULL,
	reverse_string BOOLEAN NOT NULL DEFAULT FALSE
);

INSERT INTO api.users (username, password) VALUES
	('shaco', '123'), ('clone', '456'), ('kpoud2@gmail.com', 'password');

/* TODO: remove sessions after time expires */
CREATE TABLE api.sessions (
	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	session_id TEXT NOT NULL,
	username TEXT NOT NULL
);

/* ROLES */
CREATE ROLE session_authorizer NOLOGIN;
GRANT USAGE ON SCHEMA api TO session_authorizer;
GRANT USAGE ON SCHEMA extensions TO session_authorizer;
GRANT SELECT, INSERT ON api.sessions TO session_authorizer;
GRANT SELECT, INSERT ON api.users TO session_authorizer;

CREATE ROLE web_anon NOLOGIN;
GRANT USAGE ON SCHEMA api TO web_anon;
GRANT SELECT, UPDATE(reverse_string) ON api.users TO web_anon;
GRANT SELECT ON api.sessions TO web_anon;
GRANT web_anon TO authenticator;

/* FUNCTIONS */
BEGIN;
CREATE FUNCTION api.signup(signup_username TEXT, signup_password TEXT)
RETURNS BOOLEAN AS $$
DECLARE
	exists BOOLEAN;
BEGIN
	exists := EXISTS(SELECT * FROM users WHERE username = $1);
	IF NOT exists THEN
		INSERT INTO users (username, password) VALUES ($1, $2);
		RAISE LOG 'Created new user %', $1;
		RETURN TRUE;
	END IF;
	RETURN FALSE;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;
ALTER FUNCTION api.signup(signup_username TEXT, signup_password TEXT) OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION api.signup(signup_username TEXT, signup_password TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION api.signup(signup_username TEXT, signup_password TEXT) TO web_anon;
COMMIT;

BEGIN;

/* If username and password match those of an existing user, create a session and return true */
/* On success, session_id is sent as a cookie */
CREATE FUNCTION api.login(login_username TEXT, login_password TEXT)
RETURNS BOOLEAN AS $$
DECLARE
	success BOOLEAN;
	new_session_id UUID;
BEGIN
	success := EXISTS(SELECT * FROM users WHERE username = $1 AND password = $2);
	IF success THEN
		new_session_id := gen_random_uuid();
		INSERT INTO api.sessions (session_id, username) VALUES (new_session_id, $1);
		/* TODO: Configure cookie expiration and use HTTPS + 'Secure' in cookie */
		PERFORM set_config('response.headers', format('[{"Set-Cookie": "session_id=%s; Path=/api; HttpOnly"}]', new_session_id), true);
	END IF;
	RETURN success;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;

ALTER FUNCTION api.login(login_username TEXT, login_password TEXT) OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION api.login(login_username TEXT, login_password TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION api.login(login_username TEXT, login_password TEXT) TO web_anon;

COMMIT;

CREATE EXTENSION http SCHEMA extensions;

BEGIN;
CREATE FUNCTION api.login_google(google_id_token TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    google_response JSON;
    user_email TEXT;
    user_sub TEXT;
    user_name TEXT;
    new_session_id UUID;
BEGIN
    -- Verify the Google token via Google's endpoint
    SELECT content::JSON INTO google_response
    FROM extensions.http_get(
        format('https://oauth2.googleapis.com/tokeninfo?id_token=%s', google_id_token)
    );
    -- Extract fields from Google response
    user_email := google_response->>'email';
    user_sub := google_response->>'sub';
    user_name := google_response->>'name';
	RAISE LOG 'Google login for %', user_email;

    IF user_email IS NULL OR user_sub IS NULL THEN 
        RETURN FALSE;
    END IF;

	IF NOT EXISTS(SELECT 1 FROM users WHERE LOWER(trim(username)) = LOWER(trim(user_email))) THEN
		INSERT INTO users (username, password) VALUES (user_email, user_sub);
		RAISE LOG 'Created new user for %', user_email;
	END IF;

	IF user_name IS NULL THEN
		user_name := user_email;
	END IF;

	new_session_id := gen_random_uuid();
	INSERT INTO api.sessions (session_id, username) VALUES (new_session_id, user_email);
	/* TODO: Configure cookie expiration and use HTTPS + 'Secure' in cookie */
	PERFORM set_config('response.headers', format('[{"Set-Cookie": "session_id=%s; Path=/api; HttpOnly"}]', new_session_id), true);
	RETURN TRUE;
END;
$$ LANGUAGE plpgsql
   SECURITY DEFINER
   SET search_path = api, pg_temp;
ALTER FUNCTION api.login_google(google_id_token TEXT) OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION api.login_google(google_id_token TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION api.login_google(google_id_token TEXT) TO web_anon;
COMMIT;


BEGIN;

CREATE FUNCTION validate_session()
RETURNS VOID AS $$
DECLARE
	current_session_id TEXT := current_setting('request.cookies', true)::JSON->>'session_id';
	request_path TEXT := current_setting('request.path', true);
BEGIN
	IF current_setting('request.method', true) = 'POST' AND (request_path = '/rpc/login' OR request_path = '/rpc/login_google' OR request_path = '/rpc/signup') THEN
		RETURN;
	END IF;
	IF NOT EXISTS(SELECT * FROM sessions WHERE session_id = current_session_id) THEN
		RAISE EXCEPTION 'Could not validate session';
	END IF;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;

ALTER FUNCTION validate_session() OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION validate_session() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION validate_session() TO web_anon;

COMMIT;
